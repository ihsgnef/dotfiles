\documentclass[10pt]{article}
\title{CMSC711 Midterm}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{charter}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{6pt}
\newcommand\question[2]{\vspace{.1in}\textbf{#1: #2}\vspace{.5em}\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\pagestyle{fancyplain}
\lhead{\textbf{\NAME}}
\chead{\textbf{Midterm}}
\rhead{CMSC711}
\begin{document}\raggedright
\newcommand\NAME{Shi Feng}

\question{1}{Search}\\
For all protocols, we assume that Bob (or adversary) is ``honest but curious": he
will execute the protocol as is, but might record and explore any data that
Alice sends him. To simplify the answer, false positive documents returned to
Alice are considered as a problem of correctness of the protocol rather than extra
state stored on Alice's side. We only consider word occurrence queries for
correctness, but expand to other for the analysis of supported queries. We
assume that symmetric encryption is secure.

\part{0}
P0 has perfect recall but imperfect precision.
Alice needs to store the keys for symmetric encryption. Bob needs to store the
$m$-bit output of the Bloom Filter for each document, and $r$ hash functions.
The set size $n$ is exponential in the document length.  False positive rate is
$(\frac{m}{n})^r$ when $r=\frac{m}{n}\ln 2$. The storage over head at Bob will
be large in order to get good precision.
Bob has the hash functions, so he can find out what words appear
in each document by enumerating the set of possible words. Because Bloom Filter
ignores word order and duplicate words, this protocol only supports the word
occurrence query. It will have bad precision on phrase query and word occurrence
query with specified number of occurrences.

\part{0a}
Compared to P0, P0a has extra security guarantee that Bob cannot know the
original word occurrence in each document.
It requires extra storage of word hash function for Alice.
Other properties remain the same.

\part{1}
This protocol can correctly return all and only documents containing the search
terms. 
The only storage overhead is the hash functions on Alice's side. 
In terms of security, this is equivalent to a substitution cipher and is
susceptible to frequency analysis.
Since Bob performs string match, this protocol supports any kind of string
matching query, including word occurrence and phrase occurrence.

\part{1a}
Same as P1.

\part{2} 
This protocol can correctly return all and only documents containing search
terms. 
Alice needs to store the keys for symmetric encryption and the word hash
function; Bob needs to store the inverted index. 
Bob knows the occurrences of hashed words in each document, so he can perform
frequency analysis.
This protocol, similar to P0, only supports word occurrence queries.

\part{2a}
The chaff can act as a defense against Bob's frequency analysis.

\part{se}
The computation of the pre-encrypted word $X_i=E_{k''}(W_i)$ and the key of
stream cipher $k_i=f_{k'}(X_i)$ (replace $X_i$ with $L_i$ for scheme 4) are
independent of position, so they can be cached, or pre-computed for the whole
vocabulary.

\newpage
\question{2}{Untrusted Storage}\\
For computation required for verification, we consider both sides: computing the
function for Bob, and verification for Alice.
One threat model is a third party extracting data from Bob, but we don't
consider it in this question.
Trade-off between storage and computation is possible for some protocols
(computing the checksum each time or storing them), we point them out but
strictly follow the protocol for the analysis. On top of that, we assume that
Alice minimizes her local storage, that is, she won't keep the original data if
it's not necessary for verification.
For secure protocols, by definition Bob needs to store the original data.
For insecure protocols, we analyze the minimum requirements of storage and
computation for both a well-behaved Bob and a cheating Bob.

\part{0}
This protocol is secure.
Both Alice and Bob need to store just the original data.
No computation is required for Bob. Alice needs to verify the data
which is linear time in data size. 
The communication cost for each verification is the size of the original data.

\part{1}
This protocol is not secure, as Bob only needs to store the checksum to pass the
verfication.
Alice only needs to store the checksum.
Both Alice and Bob only need to to store the checksum.
Alice needs to pre-compute the checksum, which is linear in the data size.
The communication cost of each verification equals the size of the checksum.

A well-behaved Bob needs to compute the checksum (linear in data size) for each
verification. A cheating Bob only needs to store the checksum and return it each
time.

\part{2}
This protocol is not secure if Bob knows the number 1024.
Bob can cache the permutations Alice sends and the corresponding
checksums, then he can throw away the original data after the 1024 permutations
are exhausted.
Alice need to pre-compute the 1024 permutations and the corresponding checksums,
she can them store this mapping and throw away the original data.
The communication cost for each verification is the size of a permutation from
Alice to Bob (linear in data size), plus the size of a checksum from Bob to
Alice.

A well-behaved Bob needs to compute the checksum for every permutation recevied
from Alice, which is linear in data size.
A cheating Bob would cache the permutations and the checksums, in addition to
the original data, then throw away the data after seeing 1024 different
permutations.

The security of this protocol can be easily improved by not letting Bob know the
number of permutations: he can only guess when the permutations have been
exhausted. It can also be fixed by re-generating the set of permutations after
the first set is exhausted. But this requires Alice to keep the original data.

\part{2.efficient}
This is not secure because two's complement is independent of sequence so
permutation has no effect on the checksum. Thus Bob can shuffle the data but
still pass the verification.

\part{Schwarz and Miller}
This paper proposed techniques that allow Alice to verify that untrusted
storages faithfully store her data, without her having a local copy.

The algorithm uses two main constructs: signature and parity. The signature is a
compact representation of the data that can detect small changes. The parity of
data blocks is a form of checksum. The calculations of signature and parity can
commute: the signature of party equals the parity of signature. Specifically in
this paper, the signature is the value of a $n$-degree polynomial with data
blocks as coeffecients, the parity is a m/n erasure code where the generator
matrix is obtained by performing Gaussian elimination on a Vandermonde matrix.
Both calculation operates in the same Galois field.

The protocol is: Alice calculate the parity blocks of the original data blocks,
and distribute the blocks to a single or multiple remote storages. Then Alice no
longer need her original copy, she only need the parity generator matrix. For
verification, Alice specify a chunk in the original data and a key $\alpha$, and
the remote storages return the signature of the specified chunk with the given
key. Alice then checks if the parity of the signature blocks equals the
signature of the parity block.

Although remote storage does not know the parity generation matrix, it may
construct signatures that match with the parity - one trivial case is to return
all zero signatures. Multiple remote storages may collude and construct matching
data and parity signatures. To defend, a stream cipher can be used 

\newpage
\question{3}{CRL Analysis}

\newpage
\question{4}{Ephemeral Data}


\newpage
\question{5}{Trinc BlockChain}

\end{document}
