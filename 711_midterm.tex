\documentclass[10pt]{article}
\title{CMSC711 Midterm}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{float}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{charter}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{6pt}
\newcommand\question[2]{\vspace{.1in}\textbf{#1: #2}\vspace{.5em}\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\pagestyle{fancyplain}
\lhead{\textbf{\NAME}}
\chead{\textbf{Midterm}}
\rhead{CMSC711}
\begin{document}\raggedright
\newcommand\NAME{Shi Feng}

\question{1}{Search} \\
For all protocols, we assume that Bob (or adversary) is "honest but curious": he
will execute the protocol as is, but might record and explore any data that
Alice sends him. To simplify the answer, false positive documents returned to
Alice are considered as a problem of correctness of the protocol rather than extra
state stored on Alice's side. We only consider word occurrence queries for
correctness, but expand to other for the analysis of supported queries. We
assume that symmetric encryption is secure.

\part{0}
P0 has perfect recall but imperfect precision.
Alice needs to store the keys for symmetric encryption. Bob needs to store the
$m$-bit output of the Bloom Filter for each document, and $r$ hash functions.
The set size $n$ is exponential in the document length.  False positive rate is
$(\frac{m}{n})^r$ when $r=\frac{m}{n}\ln 2$. The storage over head at Bob will
be large in order to get good precision.
Bob has the hash functions, so he can find out what words appear
in each document by enumerating the set of possible words. Because Bloom Filter
ignores word order and duplicate words, this protocol only supports the word
occurrence query. It will have bad precision on phrase query and word occurrence
query with specified number of occurrences.

\part{0a}
Compared to P0, P0a has extra security guarantee that Bob cannot know the
original word occurrence in each document.
It requires extra storage of word hash function for Alice.
Other properties remain the same.

\part{1}
This protocol can correctly return all and only documents containing the search
terms. 
The only storage overhead is the hash functions on Alice's side. 
In terms of security, this is equivalent to a substitution cipher and is
susceptible to frequency analysis.
Since Bob performs string match, this protocol supports any kind of string
matching query, including word occurrence and phrase occurrence.

\part{1a}
Same as P1.

\part{2} 
This protocol can correctly return all and only documents containing search
terms. 
Alice needs to store the keys for symmetric encryption and the word hash
function; Bob needs to store the inverted index. 
Bob knows the occurrences of hashed words in each document, so he can perform
frequency analysis.
This protocol, similar to P0, only supports word occurrence queries.

\part{2a}
The chaff can act as a defense against Bob's frequency analysis.

\part{se}
The computation of the pre-encrypted word $X_i=E_{k''}(W_i)$ and the key of
stream cipher $k_i=f_{k'}(X_i)$ (replace $X_i$ with $L_i$ for scheme 4) are
independent of position, so they can be cached, or pre-computed for the whole
vocabulary.

\newpage
\question{2}{Untrusted Storage}
For computation required for verification, we consider both sides: computing the
function for Bob, and verification for Alice.

\part{0}
This protocol is secure.
No extra storage required on either side.
No computation required for Alice or Bob. But Alice needs to verify the data
which is linear time in data size. She can perform checking using probabilistic
sampling but it is out of the scope of this question.
Each time Alice and Bob perform the verification, the communication cost is the
size of the original data.

\part{1}
This protocol is not secure, as Bob only needs to store the checksum to pass the
verfication.
The storage overhead for Alice is the checksum, or she can compute it for every
verification. Bob doesn't need to store any extra state.
Computation of the checksum for both Alice and Bob is linear in the data size.
The communication cost of a verification equals the size of the checksum.

\part{2}
This protocol is secure. Bob cannot know the set of the permutations as Alice
uses a secret PRNG, so storing the signatures instead of the data will be too
expensive. Even if he caches the permutations Alice sends and the corresponding
checksums, he wouldn't know when to throw away the original data. Because Alice
can generate a new set of permutations when the first set is exhausted.
Storage overhead for Alice is flexible: she can generate the permutation 
for each verification on the fly using a fixed seed (and reset after 1024), in
which case the overhead is just the seed. Or she can choose to pre-compute and
store the premutations, then she can still choose between storing the checksums
or computing one for each verification.
No extra state is required for Bob.
Computation of the checksum is linear time in the data size for both Alice and
Bob. Similar to storage, Alice can choose how to distribute the computation of
the checksums, beforehand or during each verification, but the total amount is
the same.
The communication cost for each verification is the size of a permutation from
Alice to Bob (linear in data size), plus the size of a checksum from Bob to
Alice.

\part{2.efficient}
This is not secure because two's complement is independent of sequence so
permutation has no effect on the checksum.

\part{Schwarz and Miller}

\newpage
\question{3}{CRL Analysis}

\newpage
\question{4}{Ephemeral Data}

\newpage
\question{5}{Trinc BlockChain}

\end{document}
